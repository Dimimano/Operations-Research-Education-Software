from manimlib.imports import *
import math
import numpy as np

class Graphing(GraphScene):

    CONFIG = {
            "x_min": 0,
            "x_max": 7,
            "y_min": 0,
            "y_max": 7,
            "function_color": WHITE,
            "axes_color": BLUE,
            "y_axis_label": "$x_2$",
            "x_axis_label": "$x_1$",
            "x_labeled_nums" : [0,1,2,3,4,5,6,7],
            "y_labeled_nums" : [0,1,2,3,4,5,6,7],
            "graph_origin": LEFT*2+DOWN*2.5,
            
        }
    
    def construct(self):
        
        self.setup_axes(animate=True)
        axes = self.axes
        func_graph = self.get_graph(lambda x : -1.5*x+6, x_min=-1,x_max=6,color = GOLD_A)
        func_graph_2 = self.get_graph(lambda x : -1.5*x+6, x_min=-1,x_max=6,color = YELLOW)
        
        graph_lab = self.get_graph_label(func_graph, label = "6x_1+4x_2 = 24")
        graph_lab_2 = self.get_graph_label(func_graph, label = "6x_1+4x_2\\le24")
        graph_lab.shift(LEFT*4)
        graph_lab_2.shift(LEFT*4)
        
        
        graph = VGroup(axes,func_graph,graph_lab,graph_lab_2,func_graph_2)
        graph.shift(LEFT*6+DOWN)
        graph.scale(0.5)
        graph_lab_2.set_color(YELLOW)
        
        
        self.play(ShowCreation(func_graph),Write(graph_lab))
        self.wait()
        
        
        text1 = TextMobject("The constraint's solution space is")
        text2 = TextMobject("the highlighted area.")
        
        text2.next_to(text1,DOWN)
        text_group_1 = VGroup(text1,text2)
        text_group_1.scale(0.5)
        text_group_1.to_corner(UP+RIGHT,buff=3.8)
        
        
        self.play(FadeIn(text_group_1))
        self.play(ReplacementTransform(graph_lab,graph_lab_2))
        self.play(ReplacementTransform(func_graph,func_graph_2))
        self.wait(2)
        
        text3 = TextMobject("We can now draw the rest of the constraints")
        text4 = TextMobject("and use the same method to determine the half-plane")
        text5 = TextMobject("decipting their solution spaces.")
        
        text4.next_to(text3,DOWN)
        text5.next_to(text4,DOWN)
        text_group_2 = VGroup(text3,text4,text5)
        text_group_2.scale(0.5)
        text_group_2.to_corner(UP+RIGHT,buff=3.5)

        
        self.play(FadeOut(text_group_1))
        self.play(FadeIn(text_group_2))
        self.wait(3)
        self.play(FadeOut(text_group_2))
        self.play(axes.shift, RIGHT*4+UP,
                  axes.scale, 1.7)
        func_graph_3 = self.get_graph(lambda x : 3-x/2, x_min=-1,x_max=7,color = YELLOW)
        graph_lab_3 = self.get_graph_label(func_graph_3, label = "x_1+2x_2\\le6")
        graph_lab_3.shift(UP*2)
        self.play(ReplacementTransform(graph_lab_2,graph_lab_3))
        self.play(ReplacementTransform(func_graph_2,func_graph_3))
        self.wait(2)
        func_graph_4 = self.get_graph(lambda x : x+1, x_min=-1,x_max=6,color = YELLOW)
        graph_lab_4 = self.get_graph_label(func_graph_4, label = "-x_1+x_2\\le1")
        graph_lab_4.shift(DOWN)
        self.play(ReplacementTransform(graph_lab_3,graph_lab_4))
        self.play(ReplacementTransform(func_graph_3,func_graph_4))
        self.wait(2)
        func_graph_5 = self.get_graph(lambda x : 2, x_min=-1,x_max=7,color = YELLOW)
        graph_lab_5 = self.get_graph_label(func_graph_5, label = "x_2\\le2")
        graph_lab_5.shift(UP)
        self.play(ReplacementTransform(graph_lab_4,graph_lab_5))
        self.play(ReplacementTransform(func_graph_4,func_graph_5))
        self.wait(2)
        
        text6 = TextMobject("The problem's feasible region is drawn and at this point")
        text7 = TextMobject("we can showcase how the simplex algorithm is `moving' towards the solution.")
        text7.next_to(text6,DOWN)
        text_group_3 = VGroup(text6,text7)
        text_group_3.scale(0.5)
        text_group_3.to_corner(UP+RIGHT,buff=2)
        text_group_3.shift(DOWN+RIGHT)      
        self.play(ReplacementTransform(graph_lab_5,text6))
        self.play(ReplacementTransform(func_graph_5,text7))
        self.wait(4)
        
        text9 = TextMobject("The points of interesection between the costraints boundaries,")
        text10 = TextMobject("especially the ones at the corners of the feasible region,")
        text11 = TextMobject("have some very important properties.")
        text10.next_to(text9,DOWN)
        text11.next_to(text10,DOWN)
        text_group_4 = VGroup(text9,text10,text11)
        text_group_4.scale(0.5)
        text_group_4.to_corner(UP+RIGHT,buff=2)
        text_group_4.shift(DOWN)
        A = Dot(np.array([-3.58,-2.52,0]),color=RED,radius=0.1)
        A_Label = TextMobject("A (0,0)",color=GOLD_B)
        A_Label.next_to(A,.7*DOWN)
        A_Label.scale(0.5)
        B = Dot(np.array([0.8,-2.52,0]),color=RED,radius=0.1)
        B_Label = TextMobject("B (4,0)",color=GOLD_B)
        B_Label.next_to(B,UP)
        B_Label.scale(0.5)
        C = Dot(np.array([-0.38,-1.4,0]),color=RED,radius=0.1)
        C_Label = TextMobject("C (3,1.5)",color=GOLD_B)
        C_Label.next_to(C,UP)
        C_Label.scale(0.5)
        D = Dot(np.array([-1.43,-1.05,0]),color=RED,radius=0.1)
        D_Label = TextMobject("D (2,2)",color=GOLD_B)
        D_Label.next_to(D,UP)
        D_Label.scale(0.5)
        E  = Dot(np.array([-2.5,-1.05,0]),color=RED,radius=0.1)
        E_Label = TextMobject("E (1,2)",color=GOLD_B)
        E_Label.next_to(E,UP)
        E_Label.scale(0.5)
        F = Dot(np.array([-3.58,-1.8,0]),color=RED,radius=0.1)
        F_Label = TextMobject("F (0,1)",color=GOLD_B)
        F_Label.next_to(F,LEFT)
        F_Label.scale(0.5)
        CPF_Labels_group = VGroup(A_Label,B_Label,C_Label,D_Label,E_Label,F_Label)
        self.play(FadeOut(text_group_3))
        self.play(FadeIn(text_group_4))
        self.play(FadeIn(CPF_Labels_group))
        self.wait(5)
        self.play(FadeOut(text_group_4)) 
        
        text12_a = TextMobject("They are called")
        text12 = TextMobject("corner-point feasible solutions (CPF)",color=RED)
        text13 = TextMobject("The simplex method focuses solely on CPF solutions.")
        text14 = TextMobject("For any problem with at least one optimal solution,")
        text15 = TextMobject("finding one requires only finding a best CPF solution.")
        text12.next_to(text12_a,DOWN)
        text13.next_to(text12,DOWN)
        text14.next_to(text13,DOWN)
        text15.next_to(text14,DOWN)
        text_group_5 = VGroup(text12_a,text12,text13,text14,text15)
        text_group_5.scale(0.5)
        text_group_5.to_corner(UP+RIGHT,buff=2)
        self.play(FadeIn(text_group_5))
        self.wait(7)
        self.play(FadeOut(text_group_5))
        
        text16 = TextMobject("Whenever possible, the initialization of the simplex method")
        text17 = TextMobject("chooses the origin (all decision variables equal to zero) ")
        text18 = TextMobject("to be the initial CPF solution.")
        text19 = TextMobject("This choice eliminates the need to use algebraic procedures")
        text20 = TextMobject("to find and solve for an initial CPF solution.")
        text17.next_to(text16,DOWN)
        text18.next_to(text17,DOWN)
        text19.next_to(text18,DOWN)
        text20.next_to(text19,DOWN)
        text_group_6 = VGroup(text16,text17,text18,text19,text20)
        text_group_6.scale(0.5)
        text_group_6.to_corner(UP+RIGHT,buff=2)
        self.play(FadeIn(text_group_6))
        self.wait(8)
        self.play(FadeOut(text_group_6))
        
        text21 = TextMobject("We can see that the origin is feasible,")
        text22 = TextMobject("so it becomes the initial CPF solution.")
        text23 = TextMobject("The simplex algorithm tries to find which path")
        text24 = TextMobject("along the edges of the feasible region")
        text25 = TextMobject("has the largest rate of improvement ")
        text26 = TextMobject("in the problem's objective function. ")
        text22.next_to(text21,DOWN)
        text23.next_to(text22,DOWN)
        text24.next_to(text23,DOWN)
        text25.next_to(text24,DOWN)
        text26.next_to(text25,DOWN)
        text_group_7 = VGroup(text21,text22,text23,text24,text25,text26)
        text_group_7.scale(0.5)
        text_group_7.to_corner(UP+RIGHT,buff=2)
        self.play(FadeIn(text_group_7))
        self.wait(7)
        self.play(FadeOut(text_group_7))
        
        texta = TextMobject("The algorithm examines only the adjacent CPFs: F and B.")
        textb = TextMobject("This means that there are 2 possible paths.")
        textc = TextMobject("The algorithm chooses the path")
        textd = TextMobject("that increases the objective function value the most,")
        texte = TextMobject("since we are solving a maximazation problem.")
        textb.next_to(texta,DOWN)
        textc.next_to(textb,DOWN)
        textd.next_to(textc,DOWN)
        texte.next_to(textd,DOWN)
        text_group_0 = VGroup(texta,textb,textc,textd,texte)
        text_group_0.scale(0.5)
        text_group_0.to_corner(UP+RIGHT,buff=2)
        self.play(FadeIn(text_group_0))
        self.wait(7)
        self.play(FadeOut(text_group_0))
        
        
        text27 = TextMobject("As we already know the reduced cost of every variable,")
        text28 = TextMobject("represents the impovement rate in the objective function")
        text29 = TextMobject("per unit increase of the variable.")
        text30 = TextMobject("The algorithm chooses the path that increases the variable")
        text31 = TextMobject("with the largest reduced cost.") 
        text28.next_to(text27,DOWN)
        text29.next_to(text28,DOWN)
        text30.next_to(text29,DOWN)
        text31.next_to(text30,DOWN)
        text_group_8 = VGroup(text27,text28,text29,text30,text31)
        text_group_8.scale(0.5)
        text_group_8.to_corner(UP+RIGHT,buff=2)
        
        self.play(FadeIn(text_group_8))  
        self.wait(7)
        self.play(FadeOut(text_group_8))
        
        
        text32 = TextMobject("Variable x1 has the largest reduced cost $s_1$ = 5,")
        text33 = TextMobject("which means that the ojective function increases by 5")
        text34 = TextMobject("per unit increase in x1")
        text35 = TextMobject("This means that F is going to become")
        text36 = TextMobject("the current CPF solution!")
        ReducedCost_Label_1 = TextMobject("$s_1$ = 5",color = GOLD_B)
        ReducedCost_Label_2 = TextMobject("$s_2$ = 4",color = GOLD_B)
        ReducedCost_Label_1.next_to(text36,DOWN+1.5*RIGHT,buff=1.6)
        vector = np.array([-3.58,3.5,0])
        ReducedCost_Label_2.move_to(vector)
        ReducedCost_group = VGroup(ReducedCost_Label_1,ReducedCost_Label_2)
        ReducedCost_group.scale(0.7)
        text33.next_to(text32,DOWN)
        text34.next_to(text33,DOWN)
        text35.next_to(text34,DOWN)
        text36.next_to(text35,DOWN)
        text_group_9 = VGroup(text32,text33,text34,text35,text36)
        text_group_9.scale(0.5)
        text_group_9.to_corner(UP+RIGHT,buff=2)
        self.play(FadeIn(text_group_9))
        self.wait()
        self.play(FadeIn(ReducedCost_group))
        self.wait(7)
        self.play(FadeOut(text_group_9))
        self.play(FadeOut(ReducedCost_group)) 
  
        
        text37 = TextMobject("Using the minimum ratio test,")
        text38 = TextMobject("the algorithm knows how much to move")
        text39 = TextMobject("upon the feasible's region edge,")
        text40 = TextMobject("without exiting the feasible region")
        text41 = TextMobject("and stopping when it reaches the CPF solution B.")
        text38.next_to(text37,DOWN)
        text39.next_to(text38,DOWN)
        text40.next_to(text39,DOWN)
        text41.next_to(text40,DOWN)
        text_group_10 = VGroup(text37,text38,text39,text40,text41)
        text_group_10.scale(0.5)
        text_group_10.to_corner(UP+RIGHT,buff=2)
        self.play(FadeIn(text_group_10))
        self.wait(5)
        self.play(FadeOut(text_group_10))
        
        
        text42 = TextMobject("Once there, the algorithm recalculates the reduced costs")
        text43 = TextMobject("in order to examine if moving to an adjacent CPF solution,")
        text44 = TextMobject("would improve the objective function.")
        text43.next_to(text42,DOWN)
        text44.next_to(text43,DOWN)
        text_group_11 = VGroup(text42,text43,text44)
        text_group_11.scale(0.5)
        text_group_11.to_corner(UP+RIGHT,buff=2)
        self.play(FadeIn(text_group_11))
        self.wait(5)
        self.play(FadeOut(text_group_11))     
        
        text45 = TextMobject("Moving to CPF solution C actually improves the objective function,")
        text46 = TextMobject("so the algoritmh repeats the process. ")
        text47 = TextMobject("After calculating the reduced costs,")
        text48 = TextMobject("the algorithm determines that moving to D,")
        text49 = TextMobject("would not improve the objective function.")
        text46.next_to(text45,DOWN)
        text47.next_to(text46,DOWN)
        text48.next_to(text47,DOWN)
        text49.next_to(text48,DOWN)
        text_group_12 = VGroup(text45,text46,text47,text48,text49)
        text_group_12.scale(0.5)
        text_group_12.to_corner(UP+RIGHT,buff=1.5)
        self.play(FadeIn(text_group_12))
        self.wait(7)
        self.play(FadeOut(text_group_12))
        
        
        text50 = TextMobject("Without an avaible path of 'improvement' the algorithm stops,")
        text51 = TextMobject("upon the optimal CPF solution C.")
        text51.next_to(text50,DOWN)
        text_group_13 = VGroup(text50,text51)
        text_group_13.scale(0.5)
        text_group_13.to_corner(UP+RIGHT,buff=2)
        self.play(FadeIn(text_group_13))
        self.wait(4)
        self.play(FadeOut(text_group_13))
        
        
        text52 = TextMobject("Conclusions")
        text52.set_color_by_gradient(BLUE, GREEN)
        text52.scale(1.5)
        text52.to_edge(UP,buff=1)
        text53 = TextMobject("Although the simplex method is an algebraic procedure,")
        text54 = TextMobject("it is based on some fairly simple geometric concepts.")
        text55 = TextMobject("These concepts enable one to use the algorithm")
        text56 = TextMobject("to examine only a relatively small number of CPF solutions")
        text57 = TextMobject("before reaching and identifying an optimal solution.")
        text53.next_to(text52,DOWN,buff=.8)
        text54.next_to(text53,DOWN)
        text55.next_to(text54,DOWN)
        text56.next_to(text55,DOWN)
        text57.next_to(text56,DOWN)
        
        
        text_group_15 = VGroup(text53,text54,text55,text56,text57)
        
        self.play(ReplacementTransform(axes,text52))
        self.play(ReplacementTransform(CPF_Labels_group,text_group_15))
        self.wait(8)
        self.play(FadeOut(text_group_15))
        
        text58 = TextMobject("When the simplex method chooses an ")
        text59 = TextMobject("entering basic variable",color=GOLD_B)
        text60 = TextMobject("the geometric interpretation is that it is")
        text61 = TextMobject("choosing one of the edges",color=GOLD_B)
        text62 = TextMobject("emanating from the current CPF solution to move along.")
        text58.next_to(text52,DOWN,buff=.8)
        text59.next_to(text58,DOWN)
        text60.next_to(text59,DOWN)
        text61.next_to(text60,DOWN)
        text62.next_to(text61,DOWN)
        
        text63 = TextMobject("Increasing this entering variable from zero")
        text64 = TextMobject("(and simultaneously changing the values")
        text65 = TextMobject("of the other basic variables accordingly)")
        text66 = TextMobject("corresponds to moving along this edge.")
        text63.next_to(text52,DOWN,buff=.8)
        text64.next_to(text63,DOWN)
        text65.next_to(text64,DOWN)
        text66.next_to(text65,DOWN)
        
        text_group_16 = VGroup(text58,text59,text60,text61,text62)
        text_group_17 = VGroup(text63,text64,text65,text66)
        
        self.play(FadeIn(text_group_16))
        self.wait(7)
        self.play(ReplacementTransform(text_group_16,text_group_17))
        self.wait(6)
        self.play(FadeOut(text_group_17))
        
        text67 = TextMobject("Having one of the basic variables")
        text68 = TextMobject("(the leaving basic variable)",color=GOLD_B)
        text70 = TextMobject("decrease so far that it reaches zero corresponds to")
        text71 = TextMobject("reaching the first new constraint boundary",color=GOLD_B)
        text72 = TextMobject("at the other end of this edge of the feasible region.")
        text67.next_to(text52,DOWN,buff=.8)
        text68.next_to(text67,DOWN)
        text70.next_to(text68,DOWN)
        text71.next_to(text70,DOWN)
        text72.next_to(text71,DOWN)
        
        text_group_18 = VGroup(text67,text68,text70,text71,text72)
        self.play(FadeIn(text_group_18))
        self.wait(9)
        self.play(FadeOut(text52))
        self.play(FadeOut(text_group_18))
        self.wait()
